<!-- Do not edit. Auto-generated by Kask v0.4.0 -->

<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generating Typed HTTP Clients with gohandlers - Gohandlers</title>

    
    <link rel="stylesheet" href="/styles.propagate.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  </head>

  <body>

    <div class="site-wide-note">Machine generated documentation. <a href="https://github.com/ufukty/gohandlers/issues" target="_blank">Contribute</a> to improve quality together.</div>

    <div id="markdown-page-column-layout">

      <header>
        <nav id="sitemap">
          <details open>
            <summary>Site map</summary>
            <div class="summarized">
              

<ul>
  
  <a href="/.">gohandlers</a>
  
  
  <li>

<ul>
  
  <span>articles</span>
  
  
  <li>

<ul>
  
  <span>getting-started</span>
  
  
  <li>

<ul>
  
  <a href="/articles/getting-started/getting-started.html">Getting Started with gohandlers: Build HTTP APIs in Goâ€”Effortlessly!</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/articles/getting-started/overview.html">Overview: What Problem Does gohandlers Solve?</a>
  
  
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>using-gohandlers</span>
  
  
  <li>

<ul>
  
  <a href="/articles/using-gohandlers/the-gohandler-way.html">The gohandlers Way of Writing HTTP Handlers in Go</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/articles/using-gohandlers/understanding-binding-structs-and-tags.html">Understanding Binding Structs and Tags in gohandlers</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/articles/using-gohandlers/understanding-validation-and-custom-types.html">Understanding Validation &amp; Custom Types in gohandlers</a>
  
  
</ul>

</li>
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>reference</span>
  
  
  <li>

<ul>
  
  <span>advanced</span>
  
  
  <li>

<ul>
  
  <a href="/reference/advanced/complex-api.html">Managing Complex APIs: Advanced Tag Usage in gohandlers</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/advanced/error-handling.html">Error Handling &amp; Customization Patterns in gohandlers</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/advanced/testing-clients.html">Testing Your API with Generated Mock Clients in gohandlers</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/advanced/typed-clients.html">Generating Typed HTTP Clients with gohandlers</a>
  
  
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>commands</span>
  
  
  <li>

<ul>
  
  <a href="/reference/commands/bindings.html"><code>bindings</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/client.html"><code>client</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/list.html"><code>list</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/mock.html"><code>mock</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/validate.html"><code>validate</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/yaml.html"><code>yaml</code></a>
  
  
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>core-concepts</span>
  
  
  <li>

<ul>
  
  <a href="/reference/core-concepts/metadata-driven.html">Metadata-Driven Routing &amp; Automatic Handler Registration</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/core-concepts/overview.html">Core Concepts: Overview</a>
  
  
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>internals</span>
  
  
  <li>

<ul>
  
  <a href="/reference/internals/overview.html">Internals: Overview</a>
  
  
</ul>

</li>
</ul>

</li>
</ul>

</li>
</ul>


            </div>
          </details>
        </nav>

        
        <nav id="toc">
          <details open>
            <summary>In this page</summary>
            <div class="summarized">
              <ul>
                
                <li>
                  <a href="#generating-typed-http-clients-with-gohandlers" class="toc1">Generating Typed HTTP Clients with gohandlers</a>
                  
                  <ul>
                    
                    <li>
                      <a href="#why-typed-clients" class="toc2">ğŸ§© Why Typed Clients?</a>
                      
                    </li>
                    <li>
                      <a href="#generating-the-client-code" class="toc2">âš™ï¸ Generating the Client Code</a>
                      
                    </li>
                    <li>
                      <a href="#how-the-client-works" class="toc2">ğŸ—ï¸ How the Client Works</a>
                      
                    </li>
                    <li>
                      <a href="#example-usage" class="toc2">âœ¨ Example Usage</a>
                      
                    </li>
                    <li>
                      <a href="#pooling-hosts" class="toc2">ğŸŒ Pooling &amp; Hosts</a>
                      
                    </li>
                    <li>
                      <a href="#returning-raw-responses" class="toc2">ğŸ” Returning Raw Responses</a>
                      
                    </li>
                    <li>
                      <a href="#testing-with-mocks" class="toc2">ğŸ§ª Testing with Mocks</a>
                      
                    </li>
                    <li>
                      <a href="#bonus-customizing-transport" class="toc2">ğŸ” Bonus: Customizing Transport</a>
                      
                    </li>
                    <li>
                      <a href="#summary-why-typed-clients-rock" class="toc2">âœ… Summary: Why Typed Clients Rock</a>
                      
                    </li>
                    <li>
                      <a href="#conclusion" class="toc2">ğŸ¯ Conclusion</a>
                      
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
          </details>
        </nav>
      </header>

      <script>
        function onChange(eval, callback) {
          let last;
          return () => {
            let next = eval()
            if (last != next) {
              last = next
              callback()
            }
          }
        }
        function detailsElemStateAdjuster() {
          let elems = document.querySelectorAll("nav>details")
          let summaries = document.querySelectorAll("nav>details>summary")
          return () => {
            elems.forEach(e => {
              e.open = window.innerWidth >= 700
            })
            summaries.forEach(e => {
              e.style.display = window.innerWidth >= 700 ? "none" : "block"
              e.onclick = window.innerWidth >= 700 ? (e) => { e.preventDefault() } : undefined
            })
          }
        }
        let adjuster = detailsElemStateAdjuster()
        adjuster()
        window.addEventListener("resize", onChange(() => { return window.innerWidth >= 700 }, adjuster, 100))
      </script>

      <main class="markdown">
        <h1 id="generating-typed-http-clients-with-gohandlers">Generating Typed HTTP Clients with gohandlers</h1>

<p>Building an HTTP API is only half the battle. The other half? <strong>Consuming it safely and efficiently.</strong></p>

<p>Manually crafting client code to call your Go API can lead to duplicated logic, fragile interfaces, and plenty of boilerplate. Thatâ€™s why <strong>gohandlers</strong> doesnâ€™t just generate server-side glueâ€”it also gives you <strong>typed, ready-to-use clients</strong> for your endpoints.</p>

<p>In this article, you&rsquo;ll learn how gohandlers turns your existing request/response types into a complete HTTP client, complete with automatic serialization, request building, and error parsingâ€”no manual code required.</p>

<h2 id="why-typed-clients">ğŸ§© Why Typed Clients?</h2>

<p>When you consume your own API (or someone else&rsquo;s), you often end up writing code like:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="nx">data</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">json</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">req</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewRequest</span><span class="p">(</span><span class="s">&#34;POST&#34;</span><span class="p">,</span> <span class="nx">baseURL</span><span class="o">+</span><span class="s">&#34;/pets&#34;</span><span class="p">,</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewBuffer</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nx">req</span><span class="p">.</span><span class="nx">Header</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="s">&#34;application/json&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">resp</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">DefaultClient</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">req</span><span class="p">)</span>
</span></span></code></pre>
<p>This is:</p>

<ul>
<li><strong>Verbose</strong> and easy to get wrong</li>
<li><strong>Unstructured</strong>â€”no compile-time guarantees</li>
<li><strong>Disconnected</strong> from your serverâ€™s logic and types</li>
</ul>

<p>gohandlers solves this by generating a client that knows how to:</p>

<ul>
<li>Build requests using your <code>...Request</code> types</li>
<li>Send them with standard or custom HTTP clients</li>
<li>Parse responses into your <code>...Response</code> types</li>
<li>Return typed results with minimal code</li>
</ul>

<h2 id="generating-the-client-code">âš™ï¸ Generating the Client Code</h2>

<p>After defining your handlers and binding structs, run:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">gohandlers client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --dir handlers/pets <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --pkg client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --out client.gh.go <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --v
</span></span></code></pre>
<p>This tells gohandlers to:</p>

<ul>
<li>Inspect all <code>...Request</code> and <code>...Response</code> types</li>
<li>Look up the associated handler metadata (method, path, etc.)</li>
<li>Generate a typed <code>Client</code> struct with methods for each endpoint</li>
</ul>

<p>Youâ€™ll get a file like:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">client</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Pool</span>    <span class="nx">Pool</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Doer</span>    <span class="nx">Doer</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Options</span> <span class="nx">Options</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">CreatePet</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">in</span> <span class="o">*</span><span class="nx">CreatePetRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">CreatePetResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// generated: build request, send, parse response
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre>
<h2 id="how-the-client-works">ğŸ—ï¸ How the Client Works</h2>

<p>Each method follows this pattern:</p>

<ol>
<li><strong>Call <code>Build()</code></strong> on the request struct to create an <code>*http.Request</code></li>
<li><strong>Send</strong> the request using an injected HTTP client</li>
<li><strong>Call <code>Parse()</code></strong> on the response struct to extract the result</li>
<li><strong>Return</strong> the typed response or any errors</li>
</ol>

<p>This means all serialization logic is already defined by your struct tagsâ€”you never touch <code>json.Marshal</code> or <code>http.NewRequest</code> again.</p>

<h2 id="example-usage">âœ¨ Example Usage</h2>

<p>Assume you have:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CreatePetRequest</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Tag</span>  <span class="kt">string</span> <span class="s">`json:&#34;tag&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CreatePetResponse</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">ID</span> <span class="kt">string</span> <span class="s">`json:&#34;id&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>Then your generated client lets you call the endpoint like this:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="nx">client</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="nx">client</span><span class="p">.</span><span class="nf">StaticPool</span><span class="p">(</span><span class="s">&#34;http://localhost:8080&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nx">ctx</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">CreatePet</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">CreatePetRequest</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;Whiskers&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Tag</span><span class="p">:</span>  <span class="s">&#34;cat&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre>
<p>No need to:</p>

<ul>
<li>Manually write HTTP requests</li>
<li>Marshal structs to JSON</li>
<li>Handle content-type headers</li>
<li>Decode responses manually</li>
</ul>

<p>The generated method does all of that for you.</p>

<h2 id="pooling-hosts">ğŸŒ Pooling &amp; Hosts</h2>

<p>The generated client uses a <strong><code>Pool</code> interface</strong> to select the base URL for a request. This gives you flexibility:</p>

<ul>
<li>Use <code>StaticPool(&quot;http://localhost:8080&quot;)</code> for single-host clients</li>
<li>Implement your own pool (e.g. for sharding, round-robin, or fallback hosts)</li>
</ul>

<p>You can also override this per-request using client <code>Options</code>.</p>

<h2 id="returning-raw-responses">ğŸ” Returning Raw Responses</h2>

<p>In some cases, you might want more control over the responseâ€”headers, status code, etc. The generated client also gives you <code>...Raw</code> methods that return <code>*http.Response</code> instead of parsed structs:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">CreatePetRaw</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">CreatePetRequest</span><span class="p">{</span><span class="o">...</span><span class="p">})</span>
</span></span></code></pre>
<p>You can then manually inspect headers, body, or status if needed.</p>

<h2 id="testing-with-mocks">ğŸ§ª Testing with Mocks</h2>

<p>gohandlers can also generate a mock implementation of the same client interface:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl">gohandlers mock <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --dir handlers/pets <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --pkg client <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --out mock.gh.go <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  --v
</span></span></code></pre>
<p>Now you can write clean, predictable tests:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="nx">mock</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">client</span><span class="p">.</span><span class="nx">MockClient</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">mock</span><span class="p">.</span><span class="nx">CreatePetFunc</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">CreatePetRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">CreatePetResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">CreatePetResponse</span><span class="p">{</span><span class="nx">ID</span><span class="p">:</span> <span class="s">&#34;test123&#34;</span><span class="p">},</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>Inject <code>mock</code> wherever the real client would goâ€”no networking required.</p>

<h2 id="bonus-customizing-transport">ğŸ” Bonus: Customizing Transport</h2>

<p>The <code>Client</code> struct exposes a <code>Doer</code> interface, allowing you to:</p>

<ul>
<li>Use <code>http.DefaultClient</code></li>
<li>Inject a custom client with timeouts</li>
<li>Wrap it with middlewares (e.g. logging, retries)</li>
</ul>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="nx">client</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">client</span><span class="p">.</span><span class="nx">Doer</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">http</span><span class="p">.</span><span class="nx">Client</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Timeout</span><span class="p">:</span> <span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>Or use it with an HTTP tracing package or distributed tracing header injector.</p>

<h2 id="summary-why-typed-clients-rock">âœ… Summary: Why Typed Clients Rock</h2>

<table>
<thead>
<tr>
<th>Feature</th>
<th>Benefit</th>
</tr>
</thead>

<tbody>
<tr>
<td>Auto-generated methods</td>
<td>Eliminate manual request/response plumbing</td>
</tr>

<tr>
<td>Strongly-typed</td>
<td>Compile-time guaranteesâ€”no <code>map[string]interface{}</code></td>
</tr>

<tr>
<td>Consistent with server</td>
<td>Uses the same structs and tags as your handlers</td>
</tr>

<tr>
<td>Easy to test</td>
<td>Built-in mocks for each method</td>
</tr>

<tr>
<td>Configurable transport</td>
<td>Support for pooling, retries, and custom HTTP clients</td>
</tr>
</tbody>
</table>

<h2 id="conclusion">ğŸ¯ Conclusion</h2>

<p>Typed HTTP clients from gohandlers bridge the gap between server and consumer. They reduce friction, cut boilerplate, and give you a clean, safe way to consume your own APIs (or provide SDKs to others).</p>

<p>With one command, you gain:</p>

<ul>
<li>An interface to your entire API</li>
<li>Full control over transport</li>
<li>Easy integration with tests</li>
</ul>

<p>Youâ€™ve already defined the shape of your APIâ€”why write a client by hand? Let gohandlers do it for you.</p>

<p><strong>Code once. Use everywhere.</strong> ğŸš€</p>

      </main>

    </div>
  </body>

</html>
