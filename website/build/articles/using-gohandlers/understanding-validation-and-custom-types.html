<!-- Do not edit. Auto-generated by Kask v0.4.0 -->

<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Validation &amp; Custom Types in gohandlers - Gohandlers</title>

    
    <link rel="stylesheet" href="/styles.propagate.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
  </head>

  <body>

    <div class="site-wide-note">Machine generated documentation. <a href="https://github.com/ufukty/gohandlers/issues" target="_blank">Contribute</a> to improve quality together.</div>

    <div id="markdown-page-column-layout">

      <header>
        <nav id="sitemap">
          <details open>
            <summary>Site map</summary>
            <div class="summarized">
              

<ul>
  
  <a href="/.">gohandlers</a>
  
  
  <li>

<ul>
  
  <span>articles</span>
  
  
  <li>

<ul>
  
  <span>getting-started</span>
  
  
  <li>

<ul>
  
  <a href="/articles/getting-started/getting-started.html">Getting Started with gohandlers: Build HTTP APIs in Goâ€”Effortlessly!</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/articles/getting-started/overview.html">Overview: What Problem Does gohandlers Solve?</a>
  
  
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>using-gohandlers</span>
  
  
  <li>

<ul>
  
  <a href="/articles/using-gohandlers/the-gohandler-way.html">The gohandlers Way of Writing HTTP Handlers in Go</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/articles/using-gohandlers/understanding-binding-structs-and-tags.html">Understanding Binding Structs and Tags in gohandlers</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/articles/using-gohandlers/understanding-validation-and-custom-types.html">Understanding Validation &amp; Custom Types in gohandlers</a>
  
  
</ul>

</li>
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>reference</span>
  
  
  <li>

<ul>
  
  <span>advanced</span>
  
  
  <li>

<ul>
  
  <a href="/reference/advanced/complex-api.html">Managing Complex APIs: Advanced Tag Usage in gohandlers</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/advanced/error-handling.html">Error Handling &amp; Customization Patterns in gohandlers</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/advanced/testing-clients.html">Testing Your API with Generated Mock Clients in gohandlers</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/advanced/typed-clients.html">Generating Typed HTTP Clients with gohandlers</a>
  
  
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>commands</span>
  
  
  <li>

<ul>
  
  <a href="/reference/commands/bindings.html"><code>bindings</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/client.html"><code>client</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/list.html"><code>list</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/mock.html"><code>mock</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/validate.html"><code>validate</code></a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/commands/yaml.html"><code>yaml</code></a>
  
  
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>core-concepts</span>
  
  
  <li>

<ul>
  
  <a href="/reference/core-concepts/metadata-driven.html">Metadata-Driven Routing &amp; Automatic Handler Registration</a>
  
  
</ul>

</li>
  <li>

<ul>
  
  <a href="/reference/core-concepts/overview.html">Core Concepts: Overview</a>
  
  
</ul>

</li>
</ul>

</li>
  <li>

<ul>
  
  <span>internals</span>
  
  
  <li>

<ul>
  
  <a href="/reference/internals/overview.html">Internals: Overview</a>
  
  
</ul>

</li>
</ul>

</li>
</ul>

</li>
</ul>


            </div>
          </details>
        </nav>

        
        <nav id="toc">
          <details open>
            <summary>In this page</summary>
            <div class="summarized">
              <ul>
                
                <li>
                  <a href="#understanding-validation-custom-types-in-gohandlers" class="toc1">Understanding Validation &amp; Custom Types in gohandlers</a>
                  
                  <ul>
                    
                    <li>
                      <a href="#why-validation-matters" class="toc2">âœ… Why Validation Matters</a>
                      
                    </li>
                    <li>
                      <a href="#auto-generated-field-level-validation" class="toc2">ðŸ§© Auto-Generated Field-Level Validation</a>
                      
                    </li>
                    <li>
                      <a href="#custom-types-for-reusable-validation" class="toc2">ðŸ§  Custom Types for Reusable Validation</a>
                      
                      <ul>
                        
                        <li>
                          <a href="#example-email-type" class="toc3">Example: Email Type</a>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <a href="#reusable-validators-with-pkg-types-basics" class="toc2">ðŸ”„ Reusable Validators with <code>pkg/types/basics</code></a>
                      
                      <ul>
                        
                        <li>
                          <a href="#example-bounded-integer" class="toc3">Example: Bounded Integer</a>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <a href="#cross-field-validation" class="toc2">ðŸ”— Cross-Field Validation</a>
                      
                    </li>
                    <li>
                      <a href="#handling-optional-fields" class="toc2">ðŸ›‘ Handling Optional Fields</a>
                      
                    </li>
                    <li>
                      <a href="#testing-validation" class="toc2">ðŸ§ª Testing Validation</a>
                      
                    </li>
                    <li>
                      <a href="#best-practices" class="toc2">âœ… Best Practices</a>
                      
                    </li>
                    <li>
                      <a href="#summary" class="toc2">ðŸ”š Summary</a>
                      
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
          </details>
        </nav>
      </header>

      <script>
        function onChange(eval, callback) {
          let last;
          return () => {
            let next = eval()
            if (last != next) {
              last = next
              callback()
            }
          }
        }
        function detailsElemStateAdjuster() {
          let elems = document.querySelectorAll("nav>details")
          let summaries = document.querySelectorAll("nav>details>summary")
          return () => {
            elems.forEach(e => {
              e.open = window.innerWidth >= 700
            })
            summaries.forEach(e => {
              e.style.display = window.innerWidth >= 700 ? "none" : "block"
              e.onclick = window.innerWidth >= 700 ? (e) => { e.preventDefault() } : undefined
            })
          }
        }
        let adjuster = detailsElemStateAdjuster()
        adjuster()
        window.addEventListener("resize", onChange(() => { return window.innerWidth >= 700 }, adjuster, 100))
      </script>

      <main class="markdown">
        <h1 id="understanding-validation-custom-types-in-gohandlers">Understanding Validation &amp; Custom Types in gohandlers</h1>

<p>One of the most powerful features of <strong>gohandlers</strong> is its ability to generate consistent and thorough validation logicâ€”without adding extra boilerplate to your handlers. This is made possible by a combination of <strong>validation-aware request structs</strong> and support for <strong>custom types</strong> that encapsulate their own parsing and checking rules.</p>

<p>In this article, weâ€™ll explore how gohandlers manages validation, how to design custom types, and how to apply both in real-world scenarios.</p>

<h2 id="why-validation-matters">âœ… Why Validation Matters</h2>

<p>Validation ensures your application doesn&rsquo;t receive malformed, missing, or inconsistent data. In traditional Go APIs, you often write repetitive if-else blocks like:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Email</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">http</span><span class="p">.</span><span class="nf">Error</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&#34;email is required&#34;</span><span class="p">,</span> <span class="nx">http</span><span class="p">.</span><span class="nx">StatusBadRequest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>These checks become cumbersome to maintain, especially across many endpoints.</p>

<p>With <strong>gohandlers</strong>, validation is cleanly defined within the struct and handled via generated <code>Validate()</code> methodsâ€”without cluttering your handler logic.</p>

<h2 id="auto-generated-field-level-validation">ðŸ§© Auto-Generated Field-Level Validation</h2>

<p>gohandlers analyzes your <code>...Request</code> structs and produces a <code>Validate()</code> method for each, which returns a <code>map[string]error</code>.</p>

<p>Example:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">CreatePetRequest</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Tag</span>  <span class="kt">string</span> <span class="s">`json:&#34;tag&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>Generated:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">req</span> <span class="nx">CreatePetRequest</span><span class="p">)</span> <span class="nf">Validate</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">errs</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">error</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Name</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">errs</span><span class="p">[</span><span class="s">&#34;name&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;name is required&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Tag</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">errs</span><span class="p">[</span><span class="s">&#34;tag&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;tag is required&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">errs</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>Inside your handler, you simply call:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">errs</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Validate</span><span class="p">();</span> <span class="nb">len</span><span class="p">(</span><span class="nx">errs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusUnprocessableEntity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">json</span><span class="p">.</span><span class="nf">NewEncoder</span><span class="p">(</span><span class="nx">w</span><span class="p">).</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">errs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>No need to repeat yourself.</p>

<h2 id="custom-types-for-reusable-validation">ðŸ§  Custom Types for Reusable Validation</h2>

<p>Validation gets even more powerful when you move logic into <strong>custom types</strong>. You can define domain-specific types that:</p>

<ul>
<li>Know how to parse themselves from strings (e.g., from URL/query params)</li>
<li>Know how to validate themselves</li>
</ul>

<p>gohandlers detects and uses these interfaces automatically:</p>

<ul>
<li><code>FromRoute(string) error</code></li>
<li><code>FromQuery(string) error</code></li>
<li><code>Validate() error</code></li>
</ul>

<h3 id="example-email-type">Example: Email Type</h3>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Email</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">Email</span><span class="p">)</span> <span class="nf">FromQuery</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="nx">e</span> <span class="p">=</span> <span class="nf">Email</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">Email</span><span class="p">)</span> <span class="nf">Validate</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">!</span><span class="nx">strings</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nb">string</span><span class="p">(</span><span class="nx">e</span><span class="p">),</span> <span class="s">&#34;@&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;invalid email format&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>Used in a request struct:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">InviteUserRequest</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Email</span> <span class="nx">Email</span> <span class="s">`query:&#34;email&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>gohandlers will automatically:</p>

<ul>
<li>Call <code>FromQuery()</code> during parsing.</li>
<li>Call <code>Validate()</code> during validation.</li>
<li>Include <code>&quot;email&quot;: &quot;invalid email format&quot;</code> in the error map if needed.</li>
</ul>

<h2 id="reusable-validators-with-pkg-types-basics">ðŸ”„ Reusable Validators with <code>pkg/types/basics</code></h2>

<p>gohandlers provides a standard set of reusable wrappers in the <a href="https://github.com/ufukty/gohandlers/tree/main/pkg/types/basics" target="_blank"><code>types/basics</code></a> package:</p>

<ul>
<li><code>types.String</code>: For parsing strings with length/regex rules</li>
<li><code>types.Int</code>: For parsing integers with min/max</li>
<li><code>types.Boolean</code>: For boolean values (<code>true</code>, <code>false</code>, <code>1</code>, <code>0</code>)</li>
<li><code>types.Time</code>: For parsing RFC3339 timestamps</li>
</ul>

<h3 id="example-bounded-integer">Example: Bounded Integer</h3>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ListPetsRequest</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Limit</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Int</span> <span class="s">`query:&#34;limit&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">types</span><span class="p">.</span><span class="nx">IntRules</span><span class="p">[</span><span class="s">&#34;limit&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">types</span><span class="p">.</span><span class="nx">IntRule</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Min</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Max</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>gohandlers will enforce that <code>?limit=0</code> returns:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="p">{</span> <span class="nt">&#34;limit&#34;</span><span class="p">:</span> <span class="s2">&#34;value must be at least 1&#34;</span> <span class="p">}</span>
</span></span></code></pre>
<p>These types make it trivial to define reusable validation across many endpoints.</p>

<h2 id="cross-field-validation">ðŸ”— Cross-Field Validation</h2>

<p>While field-level checks cover most use cases, you can also define cross-field validation manually in your <code>Validate()</code> method.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">req</span> <span class="nx">CreateBookingRequest</span><span class="p">)</span> <span class="nf">Validate</span><span class="p">()</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">errs</span> <span class="o">:=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">error</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">StartTime</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">EndTime</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">errs</span><span class="p">[</span><span class="s">&#34;endTime&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;endTime must be after startTime&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">errs</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>You can combine generated validation with your own logic. If you use custom types on each field, gohandlers will still generate the wrapper that aggregates them.</p>

<h2 id="handling-optional-fields">ðŸ›‘ Handling Optional Fields</h2>

<p>If you use a pointer field (<code>*int</code>, <code>*string</code>, etc.), you can determine if a value was supplied and validate accordingly.</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SearchRequest</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Query</span> <span class="o">*</span><span class="kt">string</span> <span class="s">`query:&#34;q&#34;`</span>
</span></span><span class="line"><span class="cl">  <span class="nx">Page</span>  <span class="o">*</span><span class="kt">int</span>    <span class="s">`query:&#34;page&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>In your <code>Validate()</code> method:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Page</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="nx">req</span><span class="p">.</span><span class="nx">Page</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">errs</span><span class="p">[</span><span class="s">&#34;page&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;page must be &gt;= 1&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>This gives you full control over optional vs. required semantics.</p>

<h2 id="testing-validation">ðŸ§ª Testing Validation</h2>

<p>Because all validation lives in <code>Validate()</code> methods, itâ€™s easy to unit test:</p>
<pre tabindex="0" class="chroma"><code><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestInviteUserValidation</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">req</span> <span class="o">:=</span> <span class="nx">InviteUserRequest</span><span class="p">{</span><span class="nx">Email</span><span class="p">:</span> <span class="s">&#34;invalid-email&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">errs</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Validate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">errs</span><span class="p">[</span><span class="s">&#34;email&#34;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;expected email validation error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre>
<p>This separation also allows you to reuse request types across HTTP and non-HTTP contexts, like CLI tools or background jobs.</p>

<h2 id="best-practices">âœ… Best Practices</h2>

<ul>
<li>Use custom types to encapsulate parsing + validation logic.</li>
<li>Validate required fields explicitly using <code>Validate()</code>.</li>
<li>Prefer <code>map[string]error</code> for clear, field-level error feedback.</li>
<li>Use pointers for optional fields.</li>
<li>Adopt <code>types/basics</code> for quick rules like min/max, pattern matching, etc.</li>
<li>Keep validation logic <em>inside</em> request structsâ€”not your handler.</li>
</ul>

<h2 id="summary">ðŸ”š Summary</h2>

<p>With gohandlers, validation is:</p>

<ul>
<li><strong>Automatic:</strong> Generated for each field based on type and presence.</li>
<li><strong>Extendable:</strong> Easy to override or enhance with custom logic.</li>
<li><strong>Encapsulated:</strong> Lives alongside your request structs or custom types.</li>
<li><strong>Testable:</strong> Clean, consistent, and independently testable.</li>
</ul>

<p>By combining generated validators with domain-specific custom types, gohandlers helps you write APIs that are not only easy to buildâ€”but also hard to break.</p>

<p>Validation becomes something you <strong>declare</strong>, not something you <strong>repeat</strong>.</p>

<p>âœ¨ Happy validating!</p>

      </main>

    </div>
  </body>

</html>
