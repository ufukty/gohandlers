# Organize your code

Gohandlers enforces the best development habits on handler definitions in terms of readability and maintainability. You need to write one struct for each handler which will represent the request and response data of that handler. This way maintaining consistency across all endpoints throughout the development process for fields, types, validation and serialization becomes joy, and enforced at each `make build`.

## Package structure

Let's say you have resource "user" and actions create, read, update, delete on it. The rules and best practices combined needs you to define a central struct for holding the common dependencies of handlers:

```go
type User struct {
  JustTheCommonDeps  any
  TheOtherLayer      any
  OrTheDatabase      any
  OrARateLimiter     any
  YouWillSetThoseTho any
  NotOurBusiness     any
}
```

Then, you are expected to define your handlers with User type being the receiver:

```go
func (u *User) Create(w http.ResponseWriter, r *http.Request)
func (u *User) Read(w http.ResponseWriter, r *http.Request)
func (u *User) Update(w http.ResponseWriter, r *http.Request)
func (u *User) Delete(w http.ResponseWriter, r *http.Request)
```

You probably will put each into different files. But make sure they match the `http.HandlerFunc` signature. Gohandlers CLI recognizes handlers by the input and output parameter list. They either match at the character basis, or not. The receivers are okay to be empty, so function handlers are allowed. In fact, when you generate the helpers file on such directory with Go files that includes the combination of function and method handlers, you'll notice there will be multiple listers as they are generated separately to match its receiver to handler's receiver. More on that later in the [Listers](4.listers.md) page.

## File structure

```go
type CreateRequest struct { ... }
type CreateResponse struct { ... }
func
```
