# ðŸ§¬ Field types

## Custom (de)serialization rules

Depending on where a request/response parameter is transfered, there needs to be special encoding & decoding process handled. Even though the rules of encoding for URL path and query parts are more or less same, Gohandlers lets you define separate methods to distinguish them.

A Go type needs to implement (de)serialization methods listed below. The exact set of methods for one particular handler is decided based on the Content-Type of bodies of requests and responses that Go type is used as a field type for its bindings.

| Method         | Description                                                     |
| -------------- | --------------------------------------------------------------- |
| `.FromRoute()` | Deserializes from **route representation** to typed value       |
| `.ToRoute()`   | Serializes typed value to place in route                        |
| `.FromQuery()` | Deserializes from **query representation** to typed value       |
| `.ToQuery()`   | Serializes typed value to place in query                        |
| `.FromForm()`  | Deserializes from `x-www-form-urlencoded` body representation   |
| `.ToForm()`    | Serializes typed value to place in `x-www-form-urlencoded` body |

## Field validators

To use the request validators generated by the `validate` command, users are required to implent the `FieldValidator` interface on every type used as a field type to a request response type:

```go
type FieldValidator interface {
  Validate() any
}
```

For example, if there is a `UserId` type used as field type to a request binding, then the user needs to implement:

```go
func (u UserId) Validate() any
```

Validate methods are forbidden to perform resource intensive operations like database accesses for their purpose, as they are solely exist for being called by request validators. Which are meant to be called for filtering invalid requests as cheaply and early as possible inside handlers, prior to resourceful operations. This only allows formal inspection of values. Thus, they are mostly expected to perform length, range or pattern checks.

Field validators return **issue**'s instead of `error`s by its both technical and semantical meaning. That is because `error`s in Go meant to be private to the client, often utilized for only internal purposes. At the other than validators are expected to return ready-to-serialization values. This can be as basic as a `string` value that is worded as an explanation meant to be presented to the user dirrectly; or an error code for frontend app to use for error message localization. For fields with collection types, the return value can be a slice or map issues.

Beware that in use of the JSON encoder (or many other) for error serialization, the return value of field validators are also contrained by the JSON encoder's expectations. For example, since it can't access to the `struct`'s unexported fields, `error` values returned by the field validators will be missing in the output.

Once the request validators generated and called by your app, the IDE warnings (via `gopls`) for types with missing field validators will make the user notice problems at an instant, far before the app goes production.
