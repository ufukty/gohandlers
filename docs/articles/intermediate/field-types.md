# ðŸ§¬ Field types

## Custom (de)serialization rules

Depending on where a request/response parameter is transfered, there needs to be special encoding & decoding process handled. Even though the rules of encoding for URL path and query parts are more or less same, Gohandlers lets you define separate methods to distinguish them.

A Go type needs to implement (de)serialization methods listed below. The exact set of methods for one particular handler is decided based on the Content-Type of bodies of requests and responses that Go type is used as a field type for its bindings.

| Method         | Description                                                     |
| -------------- | --------------------------------------------------------------- |
| `.FromRoute()` | Deserializes from **route representation** to typed value       |
| `.ToRoute()`   | Serializes typed value to place in route                        |
| `.FromQuery()` | Deserializes from **query representation** to typed value       |
| `.ToQuery()`   | Serializes typed value to place in query                        |
| `.FromForm()`  | Deserializes from `x-www-form-urlencoded` body representation   |
| `.ToForm()`    | Serializes typed value to place in `x-www-form-urlencoded` body |

## Field validators

To use the request validators generated by the `validate` command, users are required to implent the `FieldValidator` interface on every type used as a field type to a request response type:

```go
type FieldValidator interface {
  Validate() any
}
```

For example, if there is a `UserId` type used as field type to a request binding, then the user needs to implement:

```go
func (u UserId) Validate() any
```

Validate methods are forbidden to perform resource intensive operations like database accesses for their purpose, as they are solely exist for being called by request validators. Which are meant to be called for filtering invalid requests as cheaply and early as possible inside handlers, prior to resourceful operations. This only allows formal inspection of values. Thus, they are mostly expected to perform length, range or pattern checks.

Field validators return **issue**s instead of `error`s for both their technical and semantical meanings. That is because Go `error` are meant to stay private to the server, often utilized for only internal purposes. At the other hand, validators are expected to return ready-to-serialization values for sending back to the client. This can be as basic as a `string` value that is worded as an explanation to the user; or an error code that will be processed by the frontend app for localization. For fields with collection types, the return value can be a slice or map issues.

Beware that return values are constrained by the constraints of serializer that will be used inside the handler for request validation issues. For example, using JSON encoder to serialize request validator response will cause the output to miss any `error` value returned by field validators. 

Once the request validators generated and called by your app, the IDE warnings (via `gopls`) for types with missing field validators will make the user notice problems at an instant, far before the app goes production.
