# 🎸 The Gohandlers Way

Writing HTTP handlers in Go is straightforward—but **repetitive boilerplate** often **creeps** into codebases. **Gohandlers** simplifies this significantly by providing a **consistent** and **maintainable** approach to handler helper creation.

This article guides you through the core philosophy and practical approach of structuring HTTP handlers, in **"the Gohandlers way"**.

---

## 🗿 Embrace a struct-driven approach

In Gohandlers, your HTTP endpoints are modeled using clearly defined request and response structs. This creates a direct mapping between your Go types and your API’s interface.

**Example Request and Response:**

```go
type GetUserRequest struct {
  Uid columns.UserId `route:"uid"`
}

type GetUserResponse struct {
  User dto.User `json:"user"`
}
```

-   Struct names clearly communicate their role (`…Request`, `…Response`).
-   Struct tags (`route`, `query`, `form`, `json`) directly express how HTTP data maps to Go fields.

---

## 😎 Consistent handler structure

With Gohandlers, each handler follows the same predictable flow:

1. **Parsing** – Transform the incoming HTTP request into a structured Go request.
2. **Validation** – Ensure input correctness through clearly defined validation methods.
3. **Business Logic** – Handle domain logic or database interactions.
4. **Responding** – Write structured responses back into HTTP responses.

Example handler implementation:

```go
type GetUserRequest struct {
  Uid columns.UserId `route:"uid"`
}

type GetUserResponse struct {
  User dto.User `json:"user"`
}

func (u *Users) GetUser(w http.ResponseWriter, r *http.Request) {
  bq := &GetUserRequest{}
  if err := bq.Parse(r); err != nil {
    // ...
  }

  if errs := bq.Validate(); len(errs) > 0 {
    // ...
  }

  user, err := u.db.GetUser(bq.UserID)
  if err != nil {
    // ...
  }

  bs := &GetUserResponse{User: user}
  if err := bs.Write(w); err != nil {
    // ...
  }
}
```

Figure: dasdad

Each handler is clear, consistent, and readable—helping teams onboard new developers and easily maintain code.

---

## 🤗 Leverage automatic code generation

The power of Gohandlers comes from its automated code generation. It transforms your simple request and response definitions into fully-fledged parsing, validation, and serialization logic, eliminating boilerplate.

---

### ⬇️ (De)serialization methods

Gohandler can generate `.Parse()`, `.Build()` and `.Write()` methods on request and response binding types based on the field tags.

#### 🪚 Request builders

Request builders are meant to be used at the client side of request, for Go based clients (such as interservices communication).

Here is an example for `.Build()` method generated by Gohandlers:

```go
func (bq ListPetsRequest) Build(host string) (*http.Request, error) {
  uri := "/pets"
  q := []string{}
  encoded, ok, err := bq.Limit.ToQuery()
  if err != nil {
    return nil, fmt.Errorf("ListPetsRequest.Limit.ToQuery: %w", err)
  }
  if ok {
    q = append(q, fmt.Sprintf("limit=%s", encoded))
  }
  if len(q) > 0 {
    uri = fmt.Sprintf("%s?%s", uri, strings.Join(q, "&"))
  }
  r, err := http.NewRequest("GET", join(host, uri), nil)
  if err != nil {
    return nil, fmt.Errorf("http.NewRequest: %w", err)
  }
  return r, nil
}
```

> 🐈 **Petstore example**  
> Locate this code in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/bindings.gh.go#L129C1-L147C2).

This one is implemened on `ListPetsRequest` and it apparently:

-   Contains one query parameter called `"limit"`,
-   Its handler is in the `/pets` path,
-   It doesn't have a body, as the body of helper doesn't contain a call to JSON encoder nor `.ToForm()` helpers (for `"form"` tagged fields).

Notice the function returns an `*http.Request` value. Caller then can use a custom client to "do" the request, use default client or even better also generate client code for the service with `client` command. This would let passing request binding, and taking response binding (and the `error`) without touching to any http related types. Gohandlers let's you describe which handlers you want to "use" or "skip" Gohandlers helpers with; so you have the flexibility.

Generated statements for setting query parameters will mind the middle return argument (`ok`) representing if the query parameter is present.

#### 🍭 Request and response parsers

Parsing methods implemented on request and response bindings are meant to be used at the receiver side of HTTP requests and responses. They are to "Unmarshal" (or "deserialize") HTTP data to typed fields, after performing proper encoding and decoding.

Here is an example for `ListPets` endpoint request binding:

```go
func (bq *ListPetsRequest) Parse(rq *http.Request) error {
  q := rq.URL.Query()
  if q.Has("limit") {
    err := bq.Limit.FromQuery(q.Get("limit"))
    if err != nil {
      return fmt.Errorf("ListPetsRequest.Limit.FromQuery: %w", err)
    }
  }
  return nil
}
```

> 🐈 **Petstore example**  
> Locate this code in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/bindings.gh.go#L149C3-L158C2).

Notice that the paresr method calls `FromQuery` method implemented on the field type by the developer. Just like it would call `.FromRoute()` for `route` tagged fields, `.FromForm()` for `form` tagged fields. For `json` tagged fields, parser method only would call the JSON decoder with the whole struct and request/response body:

```go
func (bq *CreatePetRequest) Parse(rq *http.Request) error {
  if !strings.HasPrefix(rq.Header.Get("Content-Type"), "application/json") {
    return fmt.Errorf("invalid content type for request: %s", rq.Header.Get("Content-Type"))
  }
  if err := json.NewDecoder(rq.Body).Decode(bq); err != nil {
    return fmt.Errorf("decoding body: %w", err)
  }
  return nil
}
```

> 🐈 **Petstore example**  
> Locate this code in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/bindings.gh.go#L149C3-L158C2).

Those examples are very short as the endpoints only accepts one parameter or only a JSON body. For handlers accept more parameters, parser body gets quite long and hard to manually check for every field.

#### ✏️ Response writers

Just like the request builders, and request and response parsers; response writers support all the 4 field tags mentioned earlier. Depending on the field tag combination, writer body eloquently populated with `Content-Type` check based on the body-targeting fields are either of `json` or `form`. Setting status code is handled just before serializing the body.

```go
func (bs ListPetsResponse) Write(w http.ResponseWriter) error {
  w.Header().Set("Content-Type", "application/json")
  w.WriteHeader(http.StatusOK)
  if err := json.NewEncoder(w).Encode(bs); err != nil {
    return fmt.Errorf("encoding the body: %w", err)
  }
  return nil
}
```

> 🐈 **Petstore example**  
> Locate this code in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/bindings.gh.go#L160C1-L167C2).

---

### ✅ Validators

Gohandlers automatically produces `Validate()` methods on request & response binding types. Binding type validators **aggregate errors** returned by **each field's** `Validate` method. Which Gohandlers lets you to implement. Thus your domain-specific validation rules are stored at one place and reused at every request/response validation. Here is an example of produced validators:

```go
func (bq CreatePetRequest) Validate() (errs map[string]error) {
  errs = map[string]error{}
  if err := bq.Name.Validate(); err != nil {
    errs["name"] = err
  }
  if err := bq.Tag.Validate(); err != nil {
    errs["tag"] = err
  }
  return
}
```

> 🐈 **Petstore example**  
> Locate this code in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/validate.gh.go#L5-L14).

Notice the return type is not a simple `error`, but a `map` which collects all of the errors from problematic field, instead of returning after the first error.

Gohandlers doesn't serialize the aggregated errors, as it's up to your handler's response **content type**. For API handlers, you might prefer returning a JSON object; for HTML serving web servers you might have your custom templates to present information to user.

---

### ➡️ Handler listing

Gohandlers can generate a metadata-driven registry for seamless endpoint registration and documentation. The file contain a function called `ListHandlers` returns all the handlers declared in the directory. For handlers that are defined on structs —methods— Gohandlers create `ListHandlers` as methods on their receiver.

```go
func (pe *Pets) ListHandlers() map[string]HandlerInfo {
  return map[string]HandlerInfo{
    "CreatePet": {Method: "POST", Path: "/create-pet", Ref: pe.CreatePet},
    "DeletePet": {Method: "DELETE", Path: "/pets/{id}", Ref: pe.DeletePet},
    "GetPet":    {Method: "GET", Path: "/pets/{id}", Ref: pe.GetPet},
    "ListPets":  {Method: "GET", Path: "/pets", Ref: pe.ListPets},
  }
}
```

> 🐈 **Petstore example**  
> Locate this code in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/list.gh.go#L13-L20).

Notice the `.ListHandlers()` have `HandlerInfo` type we didn't mention so far. As the handler metadata is combination of 3 values; method, path and the function/method pointer, it needs to return a struct. The generated file will contain the `HandlerInfo` declaration which will be reused by all the `ListHandlers` function and methods in the file. But, if you need a central declaration in the consumer side of `ListHandlers` the `list` command lets you bring your `HandlerInfo` declaration by importing from your package.

---

#### 🥛 Simplified handler registration

The `.ListHandlers()` function or methods can then be easily integrated into your router setup:

```go
u := users.New(db)
s := http.NewServeMux()
for _, h := range u.ListHandlers() {
  s.HandleFunc(fmt.Spintf("%s %s", h.Method, h.Path), h.Ref)
}
_ = http.ListenAndServe(":8080", s)
```

This approach guarantees synchronization between your route definitions and actual handler implementations.

> 💡 **Suggestion**  
> Group your handlers by implementing them on different structs to be able to register them later with section or resource specific prefixes.

---

### 🤙 Client generation

Since Gohandlers already produced the request and response (de)serializors, implementing a Go based client for your Go services become trivial. By generating clients with Gohandlers, you get strongly typed clients for interacting with your API always in-sync with latest request response parameters and route path and method changes.

Here is an example client method. This one is for the List Pets endpoint we reviewed earlier:

```go
func (c *Client) ListPets(bq *pets.ListPetsRequest) (*pets.ListPetsResponse, error) {
  h, err := c.p.Host()
  if err != nil {
    return nil, fmt.Errorf("Host: %w", err)
  }
  rq, err := bq.Build(h)
  if err != nil {
    return nil, fmt.Errorf("Build: %w", err)
  }
  rs, err := http.DefaultClient.Do(rq)
  if err != nil {
    return nil, fmt.Errorf("Do: %w", err)
  }
  if rs.StatusCode != http.StatusOK {
    return nil, fmt.Errorf("non-200 status code: %d (%s)", rs.StatusCode, http.StatusText(rs.StatusCode))
  }
  bs := &pets.ListPetsResponse{}
  err = bs.Parse(rs)
  if err != nil {
    return nil, fmt.Errorf("Parse: %w", err)
  }
  return bs, nil
}
```

> 🐈 **Petstore example**  
> Locate this code in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/client/client.gh.go#L90C1-L112C2).

Notice the method starts with calling a `.Host()` method. This allows you to pass a load balancer like mechanism under the client which should randomly distribute the load to `n` instance of the server.

The calls to `.Build()`, default client's `.Do()` and `.Parse()` suits to the casuals. For endpoints doesn't have a response binding, the client method will return the raw `*http.Reponse` value.

### 🧪 Mock clients

To just pass a dummy value in consumer side unit tests, Gohandlers can generate a mock implementation of the actual client struct. The generated file will start with an interface letting you to define your dependency type to accept both the actual client in normal run and the mock client in unit tests doesn't require the real communication.

```go
type Interface interface {
  CreatePet(*pets.CreatePetRequest) (*pets.CreatePetResponse, error)
  DeletePet(*pets.DeletePetRequest) (*http.Response, error)
  GetPet(*pets.GetPetRequest) (*pets.GetPetResponse, error)
  ListPets(*pets.ListPetsRequest) (*pets.ListPetsResponse, error)
}
```

> 🐈 **Petstore example**  
> Locate this code in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/client/mock.gh.go#L10-L15).

Then, the file will contain an empty struct definition called `Mock` perfectly complies the interface above, but all the method bodies are empty.

---

## 🎨 Custom field validation rules

Your business logic stays in custom types, completely separate from generated code. Define your own domain-specific validations and parsing methods:

```go
type Email string

func (e *Email) Validate() error {
  if !strings.Contains(string(*e), "@") {
    return errors.New("invalid email address")
  }
  return nil
}
```

This allows Gohandlers to remain focused purely on generating HTTP-related boilerplate, while your custom types encapsulate domain rules clearly.

---

## 🤔 Why adopt the gohandlers approach?

-   **Consistency:** Every handler shares the same clear structure.
-   **Reduced Boilerplate:** Automated generation removes tedious, repetitive code.
-   **Clear Separation:** Business logic remains separated from HTTP-handling concerns.
-   **Maintainability:** Struct-driven definitions and generated handlers simplify ongoing maintenance and evolution.

By embracing these principles, Gohandlers helps your team build maintainable, scalable, and reliable HTTP APIs—letting you focus more on your application’s core logic, and less on boilerplate HTTP code.
