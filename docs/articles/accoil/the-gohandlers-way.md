# 🎸 The Gohandlers Way

Writing HTTP handlers in Go is straightforward—but repetitive boilerplate often creeps into your codebase. **Gohandlers** simplifies this significantly by providing a consistent, maintainable approach to handler creation and management.

This article guides you through the core philosophy and practical approach of structuring HTTP handlers, "the Gohandlers way."

---

## 🗿 Embrace a Struct-Driven Approach

In Gohandlers, your HTTP endpoints are modeled using clearly defined request and response structs. This creates a direct mapping between your Go types and your API’s interface.

**Example Request and Response:**

```go
type GetUserRequest struct {
  Uid columns.UserId `route:"uid"`
}

type GetUserResponse struct {
  User dto.User `json:"user"`
}
```

-   Struct names clearly communicate their role (`…Request`, `…Response`).
-   Struct tags (`route`, `query`, `form`, `json`) directly express how HTTP data maps to Go fields.

---

## 😎 Consistent Handler Structure

With Gohandlers, each handler follows the same predictable flow:

1. **Parsing** – Transform the incoming HTTP request into a structured Go request.
2. **Validation** – Ensure input correctness through clearly defined validation methods.
3. **Business Logic** – Handle domain logic or database interactions.
4. **Responding** – Write structured responses back into HTTP responses.

Example handler implementation:

```go
type GetUserRequest struct {
  Uid columns.UserId `route:"uid"`
}

type GetUserResponse struct {
  User dto.User `json:"user"`
}

func (u *Users) GetUser(w http.ResponseWriter, r *http.Request) {
  bq := &GetUserRequest{}
  if err := bq.Parse(r); err != nil {
    // ...
  }

  if errs := bq.Validate(); len(errs) > 0 {
    // ...
  }

  user, err := u.db.GetUser(bq.UserID)
  if err != nil {
    // ...
  }

  bs := &GetUserResponse{User: user}
  if err := bs.Write(w); err != nil {
    // ...
  }
}
```

Figure: dasdad

Each handler is clear, consistent, and readable—helping teams onboard new developers and easily maintain code.

---

## 🤗 Leverage Automatic Code Generation

The power of Gohandlers comes from its automated code generation. It transforms your simple request and response definitions into fully-fledged parsing, validation, and serialization logic, eliminating boilerplate.

---

### ⬇️ Automatic Binding Generation

Gohandler can generate `.Parse()`, `.Build()` and `.Write()` methods on request and response binding types based on the field tags.

Here is an example for `.Build()` method generated by Gohandlers.

```go
func (bq ListPetsRequest) Build(host string) (*http.Request, error) {
  uri := "/pets"
  q := []string{}
  encoded, ok, err := bq.Limit.ToQuery()
  if err != nil {
    return nil, fmt.Errorf("ListPetsRequest.Limit.ToQuery: %w", err)
  }
  if ok {
    q = append(q, fmt.Sprintf("limit=%s", encoded))
  }
  if len(q) > 0 {
    uri = fmt.Sprintf("%s?%s", uri, strings.Join(q, "&"))
  }
  r, err := http.NewRequest("GET", join(host, uri), nil)
  if err != nil {
    return nil, fmt.Errorf("http.NewRequest: %w", err)
  }
  return r, nil
}
```

> 🐈 **Petstore example**  
> Locate this snippet in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/bindings.gh.go#L129C1-L147C2).

This one is implemened on `ListPetsRequest` and it apparently:

-   Contains one query parameter called `"limit"`,
-   Its handler is in the `/pets` path,
-   It doesn't have a body, as the body of helper doesn't contain a call to JSON encoder nor `.ToForm()` helpers (for `"form"` tagged fields).

---

### ✅ Generating request/response validators

Gohandlers automatically produces `Validate()` methods on request & response binding types. Binding type validators **aggregate errors** returned by **each field's** `Validate` method. Which Gohandlers lets you to implement. Thus your domain-specific validation rules are stored at one place and reused at every request/response validation. Here is an example of produced validators:

```go
func (bq CreatePetRequest) Validate() (errs map[string]error) { //<<1>>
  errs = map[string]error{} //<<2>>
  if err := bq.Name.Validate(); err != nil {
    errs["name"] = err
  }
  if err := bq.Tag.Validate(); err != nil {
    errs["tag"] = err
  }
  return
}
```

Figure: dsds

{.petstore}

> 🐈 **Petstore example**
> Locate this snippet in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/validate.gh.go#L5-L14).

Notice <<1>> the <<2>> return type is not a simple `error`, but a `map` which reports every problematic field.

Gohandlers doesn't serialize the aggregated errors, as it's up to your handler's response **content type**. For API handlers, you might prefer returning a JSON object; for HTML serving web servers you might have your custom templates to present information to user.

---

### ↪️ Handler Listing

Gohandlers can generate a metadata-driven registry for seamless endpoint registration and documentation. The file contain a function called `ListHandlers` returns all the handlers declared in the directory. For handlers that are defined on structs —methods— Gohandlers create `ListHandlers` as methods on their receiver.

```go
func (pe *Pets) ListHandlers() map[string]HandlerInfo {
  return map[string]HandlerInfo{
    "CreatePet": {Method: "POST", Path: "/create-pet", Ref: pe.CreatePet},
    "DeletePet": {Method: "DELETE", Path: "/pets/{id}", Ref: pe.DeletePet},
    "GetPet":    {Method: "GET", Path: "/pets/{id}", Ref: pe.GetPet},
    "ListPets":  {Method: "GET", Path: "/pets", Ref: pe.ListPets},
  }
}
```

> 🐈 **Petstore example**  
> Locate this snippet in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/list.gh.go#L13-L20).

---

### 🤙 Client & Mock Generation

-   Provides strongly typed clients for interacting with your API.
-   Creates mocks for effortless testing.

---

## 🧷 Custom field validation rules

Your business logic stays in custom types, completely separate from generated code. Define your own domain-specific validations and parsing methods:

```go
type Email string

func (e *Email) Validate() error {
  if !strings.Contains(string(*e), "@") {
    return errors.New("invalid email address")
  }
  return nil
}
```

This allows Gohandlers to remain focused purely on generating HTTP-related boilerplate, while your custom types encapsulate domain rules clearly.

---

## 🥛 Simplified Handler Registration

Gone are the days of manually registering each handler. Gohandlers generates a single method to register all handlers automatically:

**Example Generated ListHandlers:**

```go
func (u *Users) ListHandlers() map[string]HandlerInfo {
  return map[string]HandlerInfo{
    "GetUser": {Method: "GET", Path: "/users/{userId}", Ref: u.GetUser},
    "CreateUser": {Method: "POST", Path: "/users", Ref: u.CreateUser},
  }
}
```

This method can then be easily integrated into your router setup:

```go
mux := http.NewServeMux()
for _, h := range NewUsersHandler(db).ListHandlers() {
  mux.HandleFunc(h.Path, h.Ref)
}
http.ListenAndServe(":8080", mux)
```

This approach guarantees synchronization between your route definitions and actual handler implementations.

---

## 🧪 Testing Made Easy

With generated mock clients, testing your handlers and business logic becomes straightforward:

```go
mock := &MockClient{}
mock.GetUserFunc = func(ctx context.Context, id string) (*GetUserResponse, error) {
  return &GetUserResponse{User: UserDTO{ID: id, Name: "Test User"}}, nil
}
```

Inject these mocks into your unit tests for predictable, reliable, and isolated testing scenarios.

---

## 🤔 Why Adopt the Gohandlers Approach?

-   **Consistency:** Every handler shares the same clear structure.
-   **Reduced Boilerplate:** Automated generation removes tedious, repetitive code.
-   **Clear Separation:** Business logic remains separated from HTTP-handling concerns.
-   **Maintainability:** Struct-driven definitions and generated handlers simplify ongoing maintenance and evolution.

By embracing these principles, Gohandlers helps your team build maintainable, scalable, and reliable HTTP APIs—letting you focus more on your application’s core logic, and less on boilerplate HTTP code.
