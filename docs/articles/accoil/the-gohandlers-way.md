# ðŸŽ¸ The Gohandlers Way

Writing HTTP handlers in Go is straightforwardâ€”but repetitive boilerplate often creeps into your codebase. **Gohandlers** simplifies this significantly by providing a consistent, maintainable approach to handler creation and management.

This article guides you through the core philosophy and practical approach of structuring HTTP handlers, "the Gohandlers way."

---

## ðŸ—¿ Embrace a Struct-Driven Approach

In Gohandlers, your HTTP endpoints are modeled using clearly defined request and response structs. This creates a direct mapping between your Go types and your APIâ€™s interface.

**Example Request and Response:**

```go
type GetUserRequest struct {
  Uid columns.UserId `route:"uid"`
}

type GetUserResponse struct {
  User dto.User `json:"user"`
}
```

-   Struct names clearly communicate their role (`â€¦Request`, `â€¦Response`).
-   Struct tags (`route`, `query`, `form`, `json`) directly express how HTTP data maps to Go fields.

---

## ðŸ˜Ž Consistent Handler Structure

With Gohandlers, each handler follows the same predictable flow:

1. **Parsing** â€“ Transform the incoming HTTP request into a structured Go request.
2. **Validation** â€“ Ensure input correctness through clearly defined validation methods.
3. **Business Logic** â€“ Handle domain logic or database interactions.
4. **Responding** â€“ Write structured responses back into HTTP responses.

Example handler implementation:

```go
type GetUserRequest struct {
  Uid columns.UserId `route:"uid"`
}

type GetUserResponse struct {
  User dto.User `json:"user"`
}

func (u *Users) GetUser(w http.ResponseWriter, r *http.Request) {
  bq := &GetUserRequest{}
  if err := bq.Parse(r); err != nil {
    // ...
  }

  if errs := bq.Validate(); len(errs) > 0 {
    // ...
  }

  user, err := u.db.GetUser(bq.UserID)
  if err != nil {
    // ...
  }

  bs := &GetUserResponse{User: user}
  if err := bs.Write(w); err != nil {
    // ...
  }
}
```

Figure: dasdad

Each handler is clear, consistent, and readableâ€”helping teams onboard new developers and easily maintain code.

---

## ðŸ¤— Leverage Automatic Code Generation

The power of Gohandlers comes from its automated code generation. It transforms your simple request and response definitions into fully-fledged parsing, validation, and serialization logic, eliminating boilerplate.

---

### â¬‡ï¸ Automatic Binding Generation

Gohandler can generate `.Parse()`, `.Build()` and `.Write()` methods on request and response binding types based on the field tags.

Here is an example for `.Build()` method generated by Gohandlers.

```go
func (bq ListPetsRequest) Build(host string) (*http.Request, error) {
  uri := "/pets"
  q := []string{}
  encoded, ok, err := bq.Limit.ToQuery()
  if err != nil {
    return nil, fmt.Errorf("ListPetsRequest.Limit.ToQuery: %w", err)
  }
  if ok {
    q = append(q, fmt.Sprintf("limit=%s", encoded))
  }
  if len(q) > 0 {
    uri = fmt.Sprintf("%s?%s", uri, strings.Join(q, "&"))
  }
  r, err := http.NewRequest("GET", join(host, uri), nil)
  if err != nil {
    return nil, fmt.Errorf("http.NewRequest: %w", err)
  }
  return r, nil
}
```

> ðŸˆ **Petstore example**  
> Locate this snippet in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/bindings.gh.go#L129C1-L147C2).

This one is implemened on `ListPetsRequest` and it apparently:

-   Contains one query parameter called `"limit"`,
-   Its handler is in the `/pets` path,
-   It doesn't have a body, as the body of helper doesn't contain a call to JSON encoder nor `.ToForm()` helpers (for `"form"` tagged fields).

---

### âœ… Generating request/response validators

Gohandlers automatically produces `Validate()` methods on request & response binding types. Binding type validators **aggregate errors** returned by **each field's** `Validate` method. Which Gohandlers lets you to implement. Thus your domain-specific validation rules are stored at one place and reused at every request/response validation. Here is an example of produced validators:

```go
func (bq CreatePetRequest) Validate() (errs map[string]error) { //<<1>>
  errs = map[string]error{} //<<2>>
  if err := bq.Name.Validate(); err != nil {
    errs["name"] = err
  }
  if err := bq.Tag.Validate(); err != nil {
    errs["tag"] = err
  }
  return
}
```

Figure: dsds

{.petstore}

> ðŸˆ **Petstore example**
> Locate this snippet in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/validate.gh.go#L5-L14).

Notice <<1>> the <<2>> return type is not a simple `error`, but a `map` which reports every problematic field.

Gohandlers doesn't serialize the aggregated errors, as it's up to your handler's response **content type**. For API handlers, you might prefer returning a JSON object; for HTML serving web servers you might have your custom templates to present information to user.

---

### â†ªï¸ Handler Listing

Gohandlers can generate a metadata-driven registry for seamless endpoint registration and documentation. The file contain a function called `ListHandlers` returns all the handlers declared in the directory. For handlers that are defined on structs â€”methodsâ€” Gohandlers create `ListHandlers` as methods on their receiver.

```go
func (pe *Pets) ListHandlers() map[string]HandlerInfo {
  return map[string]HandlerInfo{
    "CreatePet": {Method: "POST", Path: "/create-pet", Ref: pe.CreatePet},
    "DeletePet": {Method: "DELETE", Path: "/pets/{id}", Ref: pe.DeletePet},
    "GetPet":    {Method: "GET", Path: "/pets/{id}", Ref: pe.GetPet},
    "ListPets":  {Method: "GET", Path: "/pets", Ref: pe.ListPets},
  }
}
```

> ðŸˆ **Petstore example**  
> Locate this snippet in the [Petstore repository](https://github.com/ufukty/gohandlers-petstore/blob/e27a907f2c1df6e6bdd51aeca8be48a802bcce81/handlers/pets/list.gh.go#L13-L20).

---

### ðŸ¤™ Client & Mock Generation

-   Provides strongly typed clients for interacting with your API.
-   Creates mocks for effortless testing.

---

## ðŸ§· Custom field validation rules

Your business logic stays in custom types, completely separate from generated code. Define your own domain-specific validations and parsing methods:

```go
type Email string

func (e *Email) Validate() error {
  if !strings.Contains(string(*e), "@") {
    return errors.New("invalid email address")
  }
  return nil
}
```

This allows Gohandlers to remain focused purely on generating HTTP-related boilerplate, while your custom types encapsulate domain rules clearly.

---

## ðŸ¥› Simplified Handler Registration

Gone are the days of manually registering each handler. Gohandlers generates a single method to register all handlers automatically:

**Example Generated ListHandlers:**

```go
func (u *Users) ListHandlers() map[string]HandlerInfo {
  return map[string]HandlerInfo{
    "GetUser": {Method: "GET", Path: "/users/{userId}", Ref: u.GetUser},
    "CreateUser": {Method: "POST", Path: "/users", Ref: u.CreateUser},
  }
}
```

This method can then be easily integrated into your router setup:

```go
mux := http.NewServeMux()
for _, h := range NewUsersHandler(db).ListHandlers() {
  mux.HandleFunc(h.Path, h.Ref)
}
http.ListenAndServe(":8080", mux)
```

This approach guarantees synchronization between your route definitions and actual handler implementations.

---

## ðŸ§ª Testing Made Easy

With generated mock clients, testing your handlers and business logic becomes straightforward:

```go
mock := &MockClient{}
mock.GetUserFunc = func(ctx context.Context, id string) (*GetUserResponse, error) {
  return &GetUserResponse{User: UserDTO{ID: id, Name: "Test User"}}, nil
}
```

Inject these mocks into your unit tests for predictable, reliable, and isolated testing scenarios.

---

## ðŸ¤” Why Adopt the Gohandlers Approach?

-   **Consistency:** Every handler shares the same clear structure.
-   **Reduced Boilerplate:** Automated generation removes tedious, repetitive code.
-   **Clear Separation:** Business logic remains separated from HTTP-handling concerns.
-   **Maintainability:** Struct-driven definitions and generated handlers simplify ongoing maintenance and evolution.

By embracing these principles, Gohandlers helps your team build maintainable, scalable, and reliable HTTP APIsâ€”letting you focus more on your applicationâ€™s core logic, and less on boilerplate HTTP code.
